### 230. 二叉搜索树中第K小的元素
```java
class Solution {
    HashMap<String,Integer> memo=new HashMap<>(); //最大的收获是hashmap的使用
    LinkedList<TreeNode> res=new LinkedList<>();
    public List<TreeNode> findDuplicateSubtrees(TreeNode root) {
        traverse(root);
        return(res);
        
    }
    String traverse(TreeNode root){
        if(root==null)
            return "#";
        String left=traverse(root.left);
        String right=traverse(root.right);
        String subTree=left+"#"+right+"#"+root.val;//生成字符串，统一格式
        int freq=memo.getOrDefault(subTree,0);//查看出现几次

        if(freq==1){
            res.add(root);//只管根结点，而且root是指针
        }
        memo.put(subTree,freq+1);//HashMap的函数
        return subTree;
    }
}
```

### 538. 把二叉搜索树转换为累加树
```cpp
class Solution {
public:
    TreeNode* convertBST(TreeNode* root) {
        traverse(root);
        return root;
    }
    int sum=0;
    void traverse(TreeNode* root){
        
        if (root == nullptr) {
            return;
        }
        traverse(root->right);//本题最大的亮点就是中序遍历可以反着来
        sum +=root->val;
        root->val=sum;
        traverse(root->left);

    }
};
```