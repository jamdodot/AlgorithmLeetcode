### 76. 最小覆盖子串
```cpp
class Solution {
public:
    string minWindow(string s, string t) {
        unordered_map<char ,int>need,windows;//元素无序
        int valid=0;
        int len=INT_MAX;
        int  left=0,right=0,start=0;
        for(char c:t){
            need[c]++;
        }
        while(right<s.size()){
            char c=s[right];
            right++;

            if(need.count(c)){//有c的键值对
                windows[c]++;
                if(windows[c]==need[c])
                {
                    valid++;
                }
            }

            while(valid==need.size()){
                if(right-left<len){
                    len=right-left;//保存长度
                    start=left;
                }
                char d=s[left];
                left++;

                if(need.count(d)){
                    if(windows[d]==need[d])
                        valid--;
                    windows[d]--;
                }

            }
            

        }
        return len==INT_MAX?"":s.substr(start,len);

    }
};

```

### 567. 字符串的排列
```cpp
class Solution {
public:
    bool checkInclusion(string s1, string s2) {
        unordered_map<char,int>need,windows;
        int left=0,right=0,len=INT_MAX;
        int valid=0;
        int start=0,end=0;
        for(char c:s1){
            need[c]++;
        }
        while(right<s2.size()){
            char c=s2[right];
            right++;
            if(need.count(c)){
                windows[c]++;
                if(windows[c]==need[c]){
                    valid++;
                }
            }

            while(valid==need.size()){
                if(right-left<len){
                    len=right-left;
                    start++;    
                }
                char d=s2[left];
                left++;

                if(need.count(d)){
                    if(windows[d]==need[d])
                        valid--;
                    windows[d]--;
                    
                }

            }

        }
        return  len==s1.size()?true:false;//必须是和子串同样的长度 但排列可以是不一样
    }
};

```
### 此题另解
```cpp
class Solution {
public:
    bool checkInclusion(string s1, string s2) {
        unordered_map<char,int>need,windows;
        int left=0,right=0,len=INT_MAX;
        int valid=0;
        int start=0,end=0;
        for(char c:s1){
            need[c]++;
        }
        while(right<s2.size()){
            char c=s2[right];
            right++;
            if(need.count(c)){
                windows[c]++;
                if(windows[c]==need[c]){
                    valid++;
                }
            }

            while(right - left >= s1.size()){
                if (valid == need.size())
                    return true;//是因为windows是右开的，相对于例子s1 = "ab" s2 = "eidbaooo"，窗口总长还是两个不是三个

                char d=s2[left];
                left++;

                if(need.count(d)){
                    if(windows[d]==need[d])
                        valid--;
                    windows[d]--;
                    
                }

            }

        }
        return  false;
    }
};

```


### 438. 找到字符串中所有字母异位词
```cpp
class Solution {
public:
    vector<int> findAnagrams(string s, string p) {
        unordered_map<char,int>need,windows;
        int left=0,right=0,len=INT_MAX;
        int valid=0;
        int start=0,end=0;
        vector<int> result;
        for(char c:p){
            need[c]++;
        }
        while(right<s.size()){
            char c=s[right];
            right++;
            if(need.count(c)){
                windows[c]++;
                if(windows[c]==need[c]){
                    valid++;
                }
            }

            while(right - left >= p.size()){
                if (valid == need.size())
                  result.push_back(left);//是因为windows是右开的，总长还是两个不是三个同上。
                char d=s[left];
                left++;

                if(need.count(d)){
                    if(windows[d]==need[d])
                        valid--;
                    windows[d]--;
                    
                }

            }

        }
        return result;
       
    }
};

```


### 3. 无重复字符的最长子串
```cpp
class Solution {
public:
    int lengthOfLongestSubstring(string s) {
        unordered_map<char,int>windows;
        int maxlen=0;
        int left=0,right=0;
        while(right<s.size()){
            char c=s[right];
            right++;
            windows[c]++;

            while(windows[c]>1){//边滑边找
                char d=s[left];
                left++;
                windows[d]--;//直到重复的移除去
            }

            maxlen=max(maxlen,right-left);//妙啊
        }
        return maxlen;

    }
};

```